# Services Page Testing Patterns

> **Generated by**: Internal Test Pattern Agent
> **Date**: 2025-10-15
> **Purpose**: Extract and document testing patterns from existing test suites for Services page implementation

## Executive Summary

This document provides a comprehensive guide to testing patterns used across the Reiki Goddess Healing codebase. These patterns have been extracted from 17+ test files covering components ranging from simple buttons to complex forms with security features. The patterns documented here should be used as the foundation for creating comprehensive tests for the Services page.

**Key Findings**:

- Consistent use of Vitest + React Testing Library
- Strong emphasis on accessibility testing (ARIA, semantic HTML, keyboard navigation)
- Comprehensive test organization with 6 core test categories
- Extensive use of mock patterns for security, forms, and external dependencies
- Focus on edge cases and error handling

---

## Table of Contents

1. [Test File Structure](#test-file-structure)
2. [Import Patterns](#import-patterns)
3. [Test Organization Categories](#test-organization-categories)
4. [Assertion Patterns](#assertion-patterns)
5. [Mock Patterns](#mock-patterns)
6. [Accessibility Testing Patterns](#accessibility-testing-patterns)
7. [Test Utilities](#test-utilities)
8. [Test Coverage Targets](#test-coverage-targets)
9. [Services Page Testing Requirements](#services-page-testing-requirements)
10. [Test Template](#test-template)

---

## Test File Structure

### Standard Test File Pattern

```typescript
import React from "react";
import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import "@testing-library/jest-dom";
import { ComponentName } from "./ComponentName";
import type { ComponentNameProps } from "./ComponentName";

// Mock external dependencies (if needed)
vi.mock("external-module", () => ({
  // mock implementation
}));

describe("ComponentName", () => {
  // Setup/Teardown
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  // Mock data
  const mockProps: ComponentNameProps = {
    // default test props
  };

  describe("Category 1", () => {
    it("should test specific behavior", () => {
      // Test implementation
    });
  });
});
```

### File Naming Convention

- **Component**: `ComponentName.tsx`
- **Test**: `ComponentName.test.tsx`
- **Location**: Same directory as component

---

## Import Patterns

### Essential Testing Imports

```typescript
// Core testing utilities
import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";

// React Testing Library
import { render, screen, fireEvent, waitFor } from "@testing-library/react";

// User event (for realistic user interactions)
import userEvent from "@testing-library/user-event";

// Jest-DOM matchers
import "@testing-library/jest-dom";

// Component and types
import { ComponentName } from "./ComponentName";
import type { ComponentProps, TypeDefinition } from "./ComponentName";
```

### Optional Imports (Context-Specific)

```typescript
// Router wrapper for components with navigation
import { RouterWrapper } from "../test-utils";

// Custom test utilities
import { customTestHelper } from "../test-utils";

// Mock data
import { mockData } from "./mockData";
```

---

## Test Organization Categories

Our codebase uses **6 primary test categories** to organize tests systematically:

### 1. Rendering Tests

**Purpose**: Verify component renders correctly with various prop configurations

```typescript
describe("Rendering", () => {
  it("should render with default props", () => {
    render(<Component />);
    expect(screen.getByText("Expected Text")).toBeInTheDocument();
  });

  it("should render with custom props", () => {
    render(<Component customProp="value" />);
    expect(screen.getByText("Custom Value")).toBeInTheDocument();
  });

  it("should apply custom className", () => {
    const { container } = render(<Component className="custom-class" />);
    const element = container.querySelector("section");
    expect(element).toHaveClass("custom-class");
  });

  it("should render conditional elements based on props", () => {
    render(<Component showOptional={false} />);
    expect(screen.queryByTestId("optional-element")).not.toBeInTheDocument();
  });
});
```

### 2. Styling Tests

**Purpose**: Verify CSS classes, inline styles, and computed styles

```typescript
describe("Styling", () => {
  it("should have correct background color", () => {
    const { container } = render(<Component />);
    const section = container.querySelector("section");
    expect(section).toHaveStyle({ backgroundColor: "#FFFBF5" });
  });

  it("should apply responsive classes", () => {
    const { container } = render(<Component />);
    const grid = container.querySelector(".grid");
    expect(grid).toHaveClass(
      "grid-cols-1",
      "sm:grid-cols-2",
      "lg:grid-cols-4"
    );
  });

  it("should apply hover styles", () => {
    render(<Component />);
    const button = screen.getByRole("button");
    expect(button).toHaveClass("hover:bg-blue-50", "hover:scale-105");
  });

  it("should position element correctly", () => {
    const { container } = render(<Component />);
    const element = container.querySelector(".absolute");
    expect(element).toHaveStyle({
      top: "50px",
      left: "688px",
      transform: "rotate(-4.85deg)",
    });
  });
});
```

### 3. Interactions Tests

**Purpose**: Test user interactions (clicks, hovers, keyboard input)

```typescript
describe("Interactions", () => {
  it("should handle button click", () => {
    const handleClick = vi.fn();
    render(<Component onClick={handleClick} />);

    fireEvent.click(screen.getByRole("button"));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it("should handle hover effects", () => {
    render(<Component />);
    const button = screen.getByRole("button");

    fireEvent.mouseEnter(button);
    expect(button).toHaveStyle({ backgroundColor: "#63D5F9" });

    fireEvent.mouseLeave(button);
    expect(button).toHaveStyle({ backgroundColor: "#FFFFFF" });
  });

  it("should handle image load errors", () => {
    render(<Component />);
    const img = screen.getByAltText("Image alt text");

    fireEvent.error(img);
    expect(img).toHaveStyle({ display: "none" });
  });

  it("should handle user input", async () => {
    const user = userEvent.setup();
    render(<Component />);

    await user.type(screen.getByLabelText(/name/i), "Test User");
    expect(screen.getByLabelText(/name/i)).toHaveValue("Test User");
  });
});
```

### 4. Accessibility Tests

**Purpose**: Ensure ARIA attributes, semantic HTML, keyboard navigation

```typescript
describe("Accessibility", () => {
  it("should have semantic section element", () => {
    const { container } = render(<Component />);
    const section = container.querySelector("section");
    expect(section).toBeInTheDocument();
  });

  it("should have proper heading hierarchy", () => {
    render(<Component />);
    const h2 = screen.getByRole("heading", { level: 2 });
    expect(h2).toHaveTextContent("Expected Heading");
  });

  it("should have accessible links", () => {
    render(<Component />);
    const links = screen.getAllByRole("link");
    expect(links).toHaveLength(4);
    links.forEach((link) => {
      expect(link).toHaveAttribute("href");
    });
  });

  it("should have alt text for images", () => {
    render(<Component />);
    const images = screen.getAllByRole("img");
    images.forEach((img) => {
      expect(img).toHaveAttribute("alt");
      expect(img.getAttribute("alt")).not.toBe("");
    });
  });

  it("should support keyboard navigation", () => {
    render(<Component />);
    const button = screen.getByRole("button");

    button.focus();
    expect(document.activeElement).toBe(button);
  });

  it("should have ARIA attributes for invalid fields", async () => {
    render(<Component />);
    const input = screen.getByLabelText(/name/i);

    fireEvent.blur(input);

    await waitFor(() => {
      expect(input).toHaveAttribute("aria-invalid", "true");
      expect(input).toHaveAttribute("aria-describedby", "name-error");
    });
  });
});
```

### 5. Responsive Behavior Tests

**Purpose**: Test responsive design, layout, and viewport-specific behavior

```typescript
describe("Responsive Behavior", () => {
  it("should use responsive grid layout", () => {
    const { container } = render(<Component />);
    const grid = container.querySelector(".grid");

    expect(grid).toHaveClass(
      "grid-cols-1",
      "sm:grid-cols-2",
      "lg:grid-cols-4"
    );
  });

  it("should apply responsive padding", () => {
    const { container } = render(<Component />);
    const wrapper = container.querySelector(".container");
    expect(wrapper).toHaveClass("px-4", "sm:px-6", "lg:px-8");
  });

  it("should apply responsive text sizes", () => {
    render(<Component />);
    const title = screen.getByText("Title");
    expect(title).toHaveClass("text-base", "sm:text-lg", "lg:text-xl");
  });

  it("should maintain aspect ratio", () => {
    const { container } = render(<Component />);
    const imageContainer = container.querySelector(".aspect-container");
    expect(imageContainer).toHaveStyle({
      width: "52px",
      height: "52px",
    });
  });
});
```

### 6. Edge Cases Tests

**Purpose**: Test boundary conditions, error states, empty states

```typescript
describe("Edge Cases", () => {
  it("should render without any props", () => {
    const { container } = render(<Component />);
    expect(container.querySelector("section")).toBeInTheDocument();
  });

  it("should handle empty arrays", () => {
    render(<Component items={[]} />);
    const { container } = render(<Component items={[]} />);
    const cards = container.querySelectorAll(".card");
    expect(cards).toHaveLength(0);
  });

  it("should handle empty strings", () => {
    render(<Component heading="" content="" />);
    const { container } = render(<Component />);
    expect(container.querySelector("section")).toBeInTheDocument();
  });

  it("should handle very long content", () => {
    const longText = "Very long text ".repeat(100);
    render(<Component content={longText} />);
    expect(screen.getByText(new RegExp(longText.slice(0, 20)))).toBeInTheDocument();
  });

  it("should handle special characters", () => {
    render(<Component text="Special & Characters <>" />);
    expect(screen.getByText("Special & Characters <>")).toBeInTheDocument();
  });

  it("should handle undefined/null props gracefully", () => {
    render(<Component optional={undefined} />);
    const { container } = render(<Component />);
    expect(container.querySelector("section")).toBeInTheDocument();
  });

  it("should handle rapid interactions", () => {
    render(<Component />);
    const button = screen.getByRole("button");

    // Rapid clicks
    fireEvent.click(button);
    fireEvent.click(button);
    fireEvent.click(button);

    // Should handle gracefully
    expect(screen.getByRole("button")).toBeInTheDocument();
  });
});
```

---

## Assertion Patterns

### DOM Query Preference Order

**Priority Order** (from most to least preferred):

1. **Role-based queries** (most accessible)
2. **Label-based queries**
3. **Text-based queries**
4. **Test ID queries**
5. **CSS selectors** (last resort)

```typescript
// 1. Role-based (PREFERRED)
screen.getByRole("button", { name: /submit/i });
screen.getByRole("heading", { level: 2 });
screen.getByRole("link", { name: /contact/i });
screen.getAllByRole("img");

// 2. Label-based (forms)
screen.getByLabelText(/email/i);
screen.getByLabelText(/phone/i);

// 3. Text-based
screen.getByText("Expected Text");
screen.getByText(/partial match/i);

// 4. Test ID (when semantic queries not possible)
screen.getByTestId("custom-icon");

// 5. CSS selectors (avoid when possible)
container.querySelector(".specific-class");
```

### Common Assertions

```typescript
// Presence/Absence
expect(element).toBeInTheDocument();
expect(element).not.toBeInTheDocument();

// Text content
expect(element).toHaveTextContent("Expected");
expect(element).toHaveTextContent(/pattern/i);

// Attributes
expect(element).toHaveAttribute("href", "/path");
expect(element).toHaveAttribute("aria-label", "Label");

// CSS Classes
expect(element).toHaveClass("class-name");
expect(element).toHaveClass("class1", "class2", "class3");

// Styles
expect(element).toHaveStyle({ backgroundColor: "#FFF" });
expect(element).toHaveStyle("width: 100px");

// Form values
expect(input).toHaveValue("value");
expect(checkbox).toBeChecked();
expect(button).toBeDisabled();

// Array/Collection
expect(array).toHaveLength(5);
expect(elements.length).toBeGreaterThan(0);
expect(elements.length).toBeGreaterThanOrEqual(2);
```

### Async Assertions

```typescript
// Wait for element to appear
await waitFor(() => {
  expect(screen.getByText("Success")).toBeInTheDocument();
});

// Wait for element to disappear
await waitFor(() => {
  expect(screen.queryByText("Loading")).not.toBeInTheDocument();
});

// Wait with timeout
await waitFor(
  () => {
    expect(screen.getByText("Data")).toBeInTheDocument();
  },
  { timeout: 3000 }
);
```

---

## Mock Patterns

### Function Mocks

```typescript
// Basic function mock
const handleClick = vi.fn();

// Mock with implementation
const handleSubmit = vi.fn().mockImplementation(async (data) => {
  return { success: true };
});

// Mock resolved value
const mockOnSubmit = vi.fn().mockResolvedValue(undefined);

// Mock rejected value
const mockOnSubmit = vi.fn().mockRejectedValue(new Error("Network error"));

// Mock return value once
mock.mockReturnValueOnce({ isValid: true });

// Verify mock calls
expect(handleClick).toHaveBeenCalledTimes(1);
expect(handleSubmit).toHaveBeenCalledWith({ name: "Test" });
expect(mock).not.toHaveBeenCalled();
```

### Module Mocks

```typescript
// Mock entire module
vi.mock("@reiki-goddess/shared-utils", () => ({
  SecurityValidator: {
    validateEmail: vi.fn(),
    validatePhone: vi.fn(),
  },
  FormRateLimit: vi.fn(),
}));

// Mock with default implementation
vi.mock("external-module", () => ({
  default: vi.fn(() => "mocked value"),
  namedExport: vi.fn(),
}));

// Mock framer-motion
vi.mock("framer-motion", () => ({
  motion: {
    div: ({ children, ...props }: any) => <div {...props}>{children}</div>,
  },
  AnimatePresence: ({ children }: any) => children,
}));
```

### Constructor Mocks

```typescript
beforeEach(() => {
  // Setup constructor mock
  (FormRateLimit as any).mockImplementation(() => ({
    checkLimit: mockCheckLimit,
    record: mockRecord,
  }));

  (SecurityMonitor as any).mockImplementation(() => ({
    log: mockLog,
  }));
});
```

### Mock Return Values by Field

```typescript
// Different return values based on input
(SecurityValidator.validateContactFormField as any).mockImplementation(
  (field: string, value: string) => {
    if (field === "name") {
      return {
        isValid: true,
        risks: [],
        sanitizedValue: "Sanitized Name",
        riskLevel: "NONE",
      };
    } else if (field === "message") {
      return {
        isValid: true,
        risks: [],
        sanitizedValue: "Sanitized Message",
        riskLevel: "NONE",
      };
    }
    return {
      isValid: true,
      risks: [],
      sanitizedValue: value,
      riskLevel: "NONE",
    };
  }
);
```

### Image Error Handling Mocks

```typescript
describe("Image Error Handling", () => {
  it("should handle image load error and show fallback", () => {
    render(<Component />);
    const img = screen.getByRole("img", { name: "Background" });

    // Simulate image error
    fireEvent.error(img);

    expect(img).toHaveStyle({ display: "none" });
    const fallback = img.nextElementSibling as HTMLElement;
    expect(fallback).toHaveStyle({ display: "block" });
  });

  it("should not break when all images fail to load", () => {
    const { container } = render(<Component />);

    // Trigger errors on all images
    const allImages = container.querySelectorAll("img");
    allImages.forEach((img) => {
      fireEvent.error(img);
    });

    // Component should still render content
    expect(screen.getByText("Expected Text")).toBeInTheDocument();
  });
});
```

---

## Accessibility Testing Patterns

### ARIA Attributes

```typescript
describe("ARIA Attributes", () => {
  it("should have proper ARIA labels for navigation", () => {
    render(<Component />);
    expect(screen.getByLabelText("Previous testimonial")).toBeInTheDocument();
    expect(screen.getByLabelText("Next testimonial")).toBeInTheDocument();
  });

  it("should have ARIA attributes for invalid fields", async () => {
    render(<Form />);
    const nameInput = screen.getByLabelText(/name/i);

    fireEvent.blur(nameInput);

    await waitFor(() => {
      expect(nameInput).toHaveAttribute("aria-invalid", "true");
      expect(nameInput).toHaveAttribute("aria-describedby", "name-error");
    });
  });

  it("should have required attributes on mandatory fields", () => {
    render(<Form />);
    expect(screen.getByLabelText(/name/i)).toHaveAttribute("required");
    expect(screen.getByLabelText(/email/i)).toHaveAttribute("required");
  });

  it("should have noValidate attribute on form", () => {
    const { container } = render(<Form />);
    const form = container.querySelector("form");
    expect(form).toHaveAttribute("novalidate");
  });
});
```

### Semantic HTML

```typescript
describe("Semantic HTML", () => {
  it("should use semantic section element", () => {
    const { container } = render(<Component />);
    const section = container.querySelector("section");
    expect(section).toBeInTheDocument();
    expect(section?.tagName).toBe("SECTION");
  });

  it("should use semantic header element", () => {
    render(<Component />);
    expect(screen.getByRole("banner")).toBeInTheDocument();
  });

  it("should use semantic footer element", () => {
    const { container } = render(<Component />);
    const footer = container.querySelector("footer");
    expect(footer).toBeInTheDocument();
  });

  it("should use semantic nav element", () => {
    render(<Component />);
    expect(screen.getByRole("navigation")).toBeInTheDocument();
  });

  it("should use semantic list elements", () => {
    const { container } = render(<Component />);
    const lists = container.querySelectorAll("ul");
    expect(lists.length).toBeGreaterThan(0);
  });
});
```

### Heading Hierarchy

```typescript
describe("Heading Hierarchy", () => {
  it("should have proper heading hierarchy", () => {
    render(<Component />);

    const h1 = screen.getByRole("heading", { level: 1 });
    expect(h1.tagName).toBe("H1");

    const h2Elements = screen.getAllByRole("heading", { level: 2 });
    expect(h2Elements.length).toBeGreaterThan(0);

    const h3Elements = screen.getAllByRole("heading", { level: 3 });
    h3Elements.forEach((h3) => {
      expect(h3.tagName).toBe("H3");
    });
  });

  it("should not skip heading levels", () => {
    render(<Component />);
    // h1 -> h2 -> h3 (correct)
    // h1 -> h3 (incorrect - skips h2)
    const headings = screen.getAllByRole("heading");
    // Verify order and hierarchy
  });
});
```

### Keyboard Navigation

```typescript
describe("Keyboard Navigation", () => {
  it("should support keyboard focus", () => {
    render(<Component />);
    const button = screen.getByRole("button");

    button.focus();
    expect(document.activeElement).toBe(button);
  });

  it("should support tab navigation", async () => {
    const user = userEvent.setup();
    render(<Component />);

    // Tab through elements
    await user.tab();
    expect(document.activeElement).toHaveAttribute("href", "/");

    await user.tab();
    expect(document.activeElement).toHaveAttribute("href", "/about");
  });

  it("should support keyboard navigation for all interactive elements", () => {
    render(<Component />);
    const links = screen.getAllByRole("link");

    links.forEach((link) => {
      link.focus();
      expect(document.activeElement).toBe(link);
    });
  });
});
```

### External Link Attributes

```typescript
describe("External Links", () => {
  it("should have proper attributes for external links", () => {
    render(<Component />);
    const externalLink = screen.getByRole("link", { name: /follow/i });

    expect(externalLink).toHaveAttribute("target", "_blank");
    expect(externalLink).toHaveAttribute("rel", "noopener noreferrer");
  });
});
```

---

## Test Utilities

### RouterWrapper

**Purpose**: Provide React Router context for components that use routing

**Location**: `/packages/shared-components/src/test-utils/RouterWrapper.tsx`

```typescript
import { MemoryRouter } from "react-router-dom";

interface RouterWrapperProps {
  children: React.ReactNode;
  initialEntries?: string[];
}

export const RouterWrapper: React.FC<RouterWrapperProps> = ({
  children,
  initialEntries = ["/"],
}) => {
  return (
    <MemoryRouter initialEntries={initialEntries}>{children}</MemoryRouter>
  );
};
```

**Usage**:

```typescript
import { RouterWrapper } from "../test-utils";

const renderWithRouter = (component: React.ReactElement) => {
  return render(<RouterWrapper>{component}</RouterWrapper>);
};

// In tests
renderWithRouter(<Header />);
renderWithRouter(<Component />, { initialEntries: ["/services"] });
```

### Custom Render Functions

```typescript
// Basic router wrapper
const renderWithRouter = (component: React.ReactElement) => {
  return render(<RouterWrapper>{component}</RouterWrapper>);
};

// With initial route
const renderWithRoute = (component: React.ReactElement, route = "/") => {
  return render(
    <RouterWrapper initialEntries={[route]}>
      {component}
    </RouterWrapper>
  );
};
```

---

## Test Coverage Targets

### Coverage Goals

Based on existing test patterns, aim for:

- **Statements**: 80-90%
- **Branches**: 75-85%
- **Functions**: 80-90%
- **Lines**: 80-90%

### Critical Coverage Areas

**Must have 100% coverage**:

1. User interactions (button clicks, form submissions)
2. Error handling and error states
3. Accessibility features
4. Security validations
5. Conditional rendering logic

**Should have high coverage (90%+)**:

1. Props validation
2. State management
3. Event handlers
4. Edge cases

**Can have lower coverage (70%+)**:

1. Styling details
2. Animation timings
3. Complex layout calculations

---

## Services Page Testing Requirements

### Component Breakdown

Based on the Services page design, tests should cover:

1. **ServicesHero Component**
   - Heading rendering
   - Background image
   - CTA button functionality
   - Responsive behavior

2. **ServiceCard Component**
   - Icon rendering
   - Title and description
   - Duration display
   - Pricing (if applicable)
   - Hover effects
   - Link functionality

3. **ServicesGrid Component**
   - Grid layout (responsive)
   - All service cards render
   - Proper spacing
   - Empty state handling

4. **ServiceDetails Component** (if applicable)
   - Full service description
   - Benefits list
   - Booking integration
   - Related services

5. **ServicesPage Integration**
   - All sections render
   - Navigation works
   - Data loading states
   - Error states

### Test Categories for Services Page

```typescript
describe("ServicesPage", () => {
  describe("Rendering", () => {
    // - Hero section renders
    // - All service cards render
    // - CTA sections render
    // - Footer renders
  });

  describe("Service Cards", () => {
    // - Each card displays icon, title, duration
    // - Cards are clickable/linkable
    // - Hover states work
    // - Empty service handling
  });

  describe("Navigation", () => {
    // - Links to service detail pages
    // - Back navigation
    // - Breadcrumb navigation
  });

  describe("Data Loading", () => {
    // - Loading states
    // - Error states
    // - Empty states
    // - Retry functionality
  });

  describe("Accessibility", () => {
    // - Semantic HTML
    // - ARIA labels
    // - Keyboard navigation
    // - Screen reader support
  });

  describe("Responsive Behavior", () => {
    // - Mobile layout
    // - Tablet layout
    // - Desktop layout
    // - Grid responsiveness
  });

  describe("Edge Cases", () => {
    // - Missing service data
    // - Very long service names
    // - Special characters
    // - Image load failures
  });
});
```

### Minimum Test Count

For comprehensive Services page coverage:

- **ServicesPage**: 15-20 tests
- **ServicesHero**: 10-15 tests
- **ServiceCard**: 20-25 tests
- **ServicesGrid**: 10-15 tests
- **ServiceDetails**: 15-20 tests (if applicable)

**Total**: ~70-95 tests for complete Services page coverage

---

## Test Template

### Basic Component Test Template

```typescript
import React from "react";
import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import "@testing-library/jest-dom";
import { ComponentName } from "./ComponentName";
import type { ComponentNameProps } from "./ComponentName";

describe("ComponentName", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  // Mock data
  const defaultProps: ComponentNameProps = {
    title: "Test Title",
    items: [],
    onAction: vi.fn(),
  };

  describe("Rendering", () => {
    it("should render with default props", () => {
      render(<ComponentName />);
      expect(screen.getByText("Expected Default Text")).toBeInTheDocument();
    });

    it("should render with custom props", () => {
      render(<ComponentName {...defaultProps} />);
      expect(screen.getByText("Test Title")).toBeInTheDocument();
    });

    it("should apply custom className", () => {
      const { container } = render(
        <ComponentName className="custom-class" />
      );
      const element = container.querySelector("section");
      expect(element).toHaveClass("custom-class");
    });
  });

  describe("Styling", () => {
    it("should have correct background color", () => {
      const { container } = render(<ComponentName />);
      const section = container.querySelector("section");
      expect(section).toHaveStyle({ backgroundColor: "#FFFBF5" });
    });

    it("should apply responsive classes", () => {
      const { container } = render(<ComponentName />);
      const grid = container.querySelector(".grid");
      expect(grid).toHaveClass(
        "grid-cols-1",
        "sm:grid-cols-2",
        "lg:grid-cols-4"
      );
    });
  });

  describe("Interactions", () => {
    it("should handle button click", () => {
      const handleClick = vi.fn();
      render(<ComponentName onAction={handleClick} />);

      fireEvent.click(screen.getByRole("button"));
      expect(handleClick).toHaveBeenCalledTimes(1);
    });

    it("should handle user input", async () => {
      const user = userEvent.setup();
      render(<ComponentName />);

      await user.type(screen.getByLabelText(/search/i), "Query");
      expect(screen.getByLabelText(/search/i)).toHaveValue("Query");
    });
  });

  describe("Accessibility", () => {
    it("should have semantic section element", () => {
      const { container } = render(<ComponentName />);
      const section = container.querySelector("section");
      expect(section).toBeInTheDocument();
    });

    it("should have proper heading hierarchy", () => {
      render(<ComponentName />);
      const heading = screen.getByRole("heading", { level: 2 });
      expect(heading).toBeInTheDocument();
    });

    it("should have alt text for images", () => {
      render(<ComponentName />);
      const images = screen.getAllByRole("img");
      images.forEach((img) => {
        expect(img).toHaveAttribute("alt");
        expect(img.getAttribute("alt")).not.toBe("");
      });
    });

    it("should support keyboard navigation", () => {
      render(<ComponentName />);
      const button = screen.getByRole("button");

      button.focus();
      expect(document.activeElement).toBe(button);
    });
  });

  describe("Responsive Behavior", () => {
    it("should apply responsive padding", () => {
      const { container } = render(<ComponentName />);
      const wrapper = container.querySelector(".container");
      expect(wrapper).toHaveClass("px-4", "sm:px-6", "lg:px-8");
    });
  });

  describe("Edge Cases", () => {
    it("should render without any props", () => {
      const { container } = render(<ComponentName />);
      expect(container.querySelector("section")).toBeInTheDocument();
    });

    it("should handle empty arrays", () => {
      render(<ComponentName items={[]} />);
      const { container } = render(<ComponentName items={[]} />);
      const cards = container.querySelectorAll(".card");
      expect(cards).toHaveLength(0);
    });

    it("should handle very long content", () => {
      const longText = "Very long text ".repeat(100);
      render(<ComponentName content={longText} />);
      expect(screen.getByText(new RegExp(longText.slice(0, 20)))).toBeInTheDocument();
    });
  });
});
```

### Form Component Test Template

```typescript
import React from "react";
import { describe, it, expect, vi, beforeEach } from "vitest";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import "@testing-library/jest-dom";
import { FormComponent } from "./FormComponent";

describe("FormComponent", () => {
  const mockOnSubmit = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe("Rendering", () => {
    it("should render all form fields", () => {
      render(<FormComponent onSubmit={mockOnSubmit} />);

      expect(screen.getByLabelText(/name/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/email/i)).toBeInTheDocument();
      expect(screen.getByRole("button", { name: /submit/i })).toBeInTheDocument();
    });
  });

  describe("Field Validation", () => {
    it("should validate name field on blur", async () => {
      render(<FormComponent onSubmit={mockOnSubmit} />);

      const nameInput = screen.getByLabelText(/name/i);
      fireEvent.blur(nameInput);

      await waitFor(() => {
        expect(screen.getByText("This field is required")).toBeInTheDocument();
      });
    });

    it("should validate email format", async () => {
      const user = userEvent.setup();
      render(<FormComponent onSubmit={mockOnSubmit} />);

      await user.type(screen.getByLabelText(/email/i), "invalid-email");
      fireEvent.blur(screen.getByLabelText(/email/i));

      await waitFor(() => {
        expect(screen.getByText("Please enter a valid email")).toBeInTheDocument();
      });
    });
  });

  describe("Form Submission", () => {
    it("should submit form with valid data", async () => {
      const user = userEvent.setup();
      mockOnSubmit.mockResolvedValueOnce(undefined);

      render(<FormComponent onSubmit={mockOnSubmit} />);

      await user.type(screen.getByLabelText(/name/i), "Test User");
      await user.type(screen.getByLabelText(/email/i), "test@example.com");
      await user.click(screen.getByRole("button", { name: /submit/i }));

      await waitFor(() => {
        expect(mockOnSubmit).toHaveBeenCalledWith({
          name: "Test User",
          email: "test@example.com",
        });
      });
    });

    it("should show loading state during submission", async () => {
      const user = userEvent.setup();
      mockOnSubmit.mockImplementation(
        () => new Promise((resolve) => setTimeout(resolve, 100))
      );

      render(<FormComponent onSubmit={mockOnSubmit} />);

      await user.type(screen.getByLabelText(/name/i), "Test User");
      await user.type(screen.getByLabelText(/email/i), "test@example.com");

      const submitButton = screen.getByRole("button", { name: /submit/i });
      await user.click(submitButton);

      expect(submitButton).toHaveTextContent("Submitting...");
      expect(submitButton).toBeDisabled();

      await waitFor(() => {
        expect(submitButton).toHaveTextContent("Submit");
        expect(submitButton).not.toBeDisabled();
      });
    });

    it("should handle submission errors", async () => {
      const user = userEvent.setup();
      mockOnSubmit.mockRejectedValueOnce(new Error("Network error"));

      render(<FormComponent onSubmit={mockOnSubmit} />);

      await user.type(screen.getByLabelText(/name/i), "Test User");
      await user.type(screen.getByLabelText(/email/i), "test@example.com");
      await user.click(screen.getByRole("button", { name: /submit/i }));

      await waitFor(() => {
        expect(screen.getByText(/error occurred/i)).toBeInTheDocument();
      });
    });
  });

  describe("Accessibility", () => {
    it("should have ARIA attributes for invalid fields", async () => {
      render(<FormComponent onSubmit={mockOnSubmit} />);

      const nameInput = screen.getByLabelText(/name/i);
      fireEvent.blur(nameInput);

      await waitFor(() => {
        expect(nameInput).toHaveAttribute("aria-invalid", "true");
        expect(nameInput).toHaveAttribute("aria-describedby", "name-error");
      });
    });

    it("should have required attributes", () => {
      render(<FormComponent onSubmit={mockOnSubmit} />);

      expect(screen.getByLabelText(/name/i)).toHaveAttribute("required");
      expect(screen.getByLabelText(/email/i)).toHaveAttribute("required");
    });
  });
});
```

---

## Best Practices Summary

### DO:

✅ Use role-based queries (`getByRole`) whenever possible
✅ Test user-facing behavior, not implementation details
✅ Write descriptive test names that explain what is being tested
✅ Group related tests in describe blocks
✅ Use `beforeEach`/`afterEach` for setup/teardown
✅ Test accessibility (ARIA, semantic HTML, keyboard navigation)
✅ Test edge cases (empty states, errors, long content)
✅ Use `waitFor` for async assertions
✅ Mock external dependencies
✅ Test responsive behavior

### DON'T:

❌ Test internal component state directly
❌ Use `querySelector` when semantic queries are available
❌ Skip accessibility tests
❌ Ignore edge cases
❌ Test CSS-in-JS implementation details
❌ Forget to clean up mocks
❌ Write tests that depend on each other
❌ Test third-party library internals
❌ Skip error handling tests
❌ Use `act()` warnings as test success indicators

---

## Quick Reference

### Most Common Test Patterns

```typescript
// 1. Basic rendering
it("should render component", () => {
  render(<Component />);
  expect(screen.getByText("Text")).toBeInTheDocument();
});

// 2. Props testing
it("should render with custom props", () => {
  render(<Component title="Custom" />);
  expect(screen.getByText("Custom")).toBeInTheDocument();
});

// 3. User interaction
it("should handle click", () => {
  const handleClick = vi.fn();
  render(<Component onClick={handleClick} />);
  fireEvent.click(screen.getByRole("button"));
  expect(handleClick).toHaveBeenCalledTimes(1);
});

// 4. Async behavior
it("should show data after loading", async () => {
  render(<Component />);
  await waitFor(() => {
    expect(screen.getByText("Data")).toBeInTheDocument();
  });
});

// 5. Accessibility
it("should be accessible", () => {
  render(<Component />);
  expect(screen.getByRole("heading", { level: 2 })).toBeInTheDocument();
  expect(screen.getByLabelText("Input")).toBeInTheDocument();
});
```

---

## Additional Resources

- **Vitest Documentation**: https://vitest.dev/
- **React Testing Library**: https://testing-library.com/react
- **Testing Library Queries**: https://testing-library.com/docs/queries/about
- **ARIA Roles**: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles
- **Existing Test Examples**:
  - `/packages/shared-components/src/Services/ServicesSection.test.tsx`
  - `/packages/shared-components/src/SecureContactForm/SecureContactForm.test.tsx`
  - `/packages/shared-components/src/Hero/HeroV2.test.tsx`

---

**End of Testing Patterns Documentation**

> Generated for Services Page implementation
> Follow these patterns for consistent, comprehensive test coverage
